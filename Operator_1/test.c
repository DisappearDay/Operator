#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//创建一个结构体类型 struct-stu  必须创建在要使用的函数的上面
struct stu
{
	char name[20];
	int age;
	char sno[20];
};
int main() {

	//移位操作符，移的是二进制位 00000000000000000000000000010000 16
	//分两种
	//1. 逻辑运算符 ：右移时，最右边的不要，往最左边补0      左移时，左边丢掉，右边补0
	//2. 算术运算符 ：右移时，最右边的不要，往最左边补与原数相同的符号，既正数补0，负数补1；    左移时，左边丢掉，右边补0
	//存到内存的是补码
	//禁止移动负数位
	//int a = 16;
	//int b = a >>1 ;
	//printf("%d\n", b);


	////移位操作符与位操作符只能作用与整数，不能作用与浮点数
	//int a = 3;            //00000000000000000000000000000011
	//int b = 5;            //00000000000000000000000000000101
	//int c = a & b;        //00000000000000000000000000000001  按位与
	////则c为1
	//int d = a | b;        //00000000000000000000000000000111  按位或
	//int e = a ^ b;        //00000000000000000000000000000110  按位异或  

	//不创建临时变量，交换两个变量的值

	//1.    加减法     用这种方法存在一定漏洞，因为a是有值范围的，如果a，b都不超过，但是a+b超过，这就不符合题了
	//int a = 3; int b = 5;
	//a = a + b;
	//b = a - b;
	//a = a - b;
	  //2.   用异或法
	//a=a^b;
	//b=a^b;
	//a=a^b;

	//输入一个数，判断该数的二进制位有几个1
	//int num = 0;
	//int count = 0;
	//printf("请输入一个数：\n");
	//scanf("%d",&num);
	//int i = 0;
	//for (i = 0; i < 32; i++)
	//{
	//	if (1 == ((num>>i) & 1)) 
	//	{
	//		
	//		count++;
	//	}
	//}
	//printf("%d\n",count);

	

	//双目操作符：有两个操作数  +   -（减）   = ・・・
	//单目操作符：只有一个操作数 ！ -（负）
	/*int a = 0;*/
	//!是指如果a为假打印hehe 
	/*if (!a) {
		printf("hehe");
	}*/

	//int a = 10;
	//int* p = &a;//取地址操作符
	//*p = 10;//解引用操作符

	//sizeof();计算的是变量所占空间的大小  整形是四个字节 char是字符是1个字节 
	// 指针是根据计算机的平台 32位的是四个字节 64位的是八个字节
	//数组也是有类型的
	//一个数组int arr[10]=0; 如果去掉数组名，剩下的就是他的类型即int arr[];



	//int a = 0;
	//short s = 0;
	//printf("%d\n", sizeof(s = a + 5));
	//printf("%d\n", s);//size中的数不参与运算 即sizeof中的s一直都是0
	//int a = 0;
	//printf("%d\n", ~a);//-1  即~的意思是按位取反



	//int a = 11;
	//a = a | (1 << 2);
	//printf("%d\n",a);  //15
	//// 1011  将某一个值变为0，则把该数字的0位置按位或上一个1就可以了
	//// 0100  将1左移两个可得到该数字
	//// 1111
	//a = a & (~(1 << 2));
	//printf("%d\n", a);  //11
	//// 1111 变回原来
	//// 1011 将1左移两位在取反可得到
	//// 1011

	//++a和a++


	//当sizeof作为参数传递时，传递是数组的首字母，而存放的地方开辟的空间大小是一个指针的大小，电脑的位数32位是四个字节，64位是八个字节


	//exp1 ? exp2 : exp3 
	//指的是如果表达式1的结果为真则表达式2要算，表达式2的结果是最终结果，
	//如果表达式1的结果为假，则表达式3的结果要算，表达式3的结果是最终结果
	//类似简单的if else

//    //逗号表达式
//int a = 1;
//int b = 2;
//int c = (a > b, a = b + 10, a, b = a + 1);//13 逗号表达式是依次从左向右执行，知道最后一个表达式的结果是c的值

//
//使用结构体类型struct-stu创建了一个学生对象s1，并初始化
 //   struct stu s1 = { "张三",22,"20200401186" };
	//printf("%s\n", s1.name);
	//printf("%d\n", s1.age);
	//printf("%s\n", s1.sno);
	//struct stu* ps = &s1;
	//printf("%s\n", (*ps).name);
	//printf("%s\n", ps->name);//和上面的性质是一摸一样，因为ps是指针，用箭头指向，箭头即是指向操作符
	//printf("%d\n", (*ps).age);
	//printf("%s\n", (*ps).sno);


  //    char a = 3;        //0000000000000000000000000011   因为是char类型所以a的值-00000011
  //    char b = 127;      //0000000000000000000001111111    b-01111111 
  //    char c = a + b;    //a+b时，进行整形提升，是按符号位进行的再相加得 //0000000000000000000010000010
	 ////因为c是char类型，进行存储的时候只保留一个字节即-10000001
	 // //输出时，因为要输出整形，然后进行整型提升，按符号位进行可得 11111111111111111111111110000001 --补码
	 // // 进行取反再加一得 1000000000000000000000001111110----1000000000000000000000001111111
	 // //即结果是-126
	 // 
	 // printf("%d\n", c);


//算数转换
     //long double>double>float>unsigned long int>long int>unsigned int>int



	return 0;
}

